package com.mentor.application.views.vendor.fragments

import android.app.DatePickerDialog
import android.content.Intent
import android.os.Bundle
import android.view.View
import android.view.View.OnClickListener
import android.widget.AdapterView
import android.widget.ArrayAdapter
import androidx.fragment.app.viewModels
import androidx.lifecycle.Observer
import com.applandeo.materialcalendarview.listeners.OnSelectDateListener
import com.mentor.application.R
import com.mentor.application.databinding.FragmentEditAvailabilityBinding
import com.mentor.application.databinding.ToolbarBinding
import com.mentor.application.repository.models.AvailabilityData
import com.mentor.application.repository.models.AvailabilityTimeSlots
import com.mentor.application.utils.Constants
import com.mentor.application.utils.Constants.REQUEST_DATE_FORMAT_SERVER
import com.mentor.application.utils.GeneralFunctions
import com.mentor.application.viewmodels.comman.BaseViewModel
import com.mentor.application.viewmodels.vendor.PersonalisationViewModel
import com.mentor.application.views.comman.activities.BaseAppCompactActivity
import com.mentor.application.views.vendor.adapters.CreateSlotsAdapter
import com.mentor.application.views.vendor.adapters.ExcludedDatesAdapter
import com.mentor.application.views.vendor.adapters.ExcludedWeekDaysAdapter
import com.mentor.application.views.vendor.fragments.MyAvailabilityFragment.Companion.INTENT_AVAILABILITY
import com.mentor.application.views.vendor.interfaces.EditAvailabilityInterface
import com.swingby.app.views.fragments.base.BaseFragment
import dagger.hilt.android.AndroidEntryPoint
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale
import javax.inject.Inject


@AndroidEntryPoint
class EditAvailabilityFragment :
    BaseFragment<FragmentEditAvailabilityBinding>(FragmentEditAvailabilityBinding::inflate),
    OnClickListener, EditAvailabilityInterface,
    OnSelectDateListener {

    companion object {
        const val SLOTS_TYPE_CUSTOM = "custom"
        const val SLOTS_TYPE_AUTO = "auto"
        const val BUNDLE_VIEW_TYPE_EDIT = 0
        const val BUNDLE_VIEW_TYPE_CREATE = 1
        const val BUNDLE_VIEW_TYPE = "viewType"
        const val BUNDLE_SELECTED_DATE = "date"
        const val BUNDLE_AVAILABILITY_DATA = "availabilityData"
        var mSlotType = SLOTS_TYPE_AUTO

        fun newInstance(
            date: String,
            viewType: Int,
            mAvailabilityData: AvailabilityData
        ): EditAvailabilityFragment {
            val args = Bundle()
            val fragment = EditAvailabilityFragment()
            args.putString(BUNDLE_SELECTED_DATE, date)
            args.putInt(BUNDLE_VIEW_TYPE, viewType)
            args.putParcelable(BUNDLE_AVAILABILITY_DATA, mAvailabilityData)
            fragment.arguments = args
            return fragment
        }
    }

    private val mViewModel: PersonalisationViewModel by viewModels()

    @Inject
    lateinit var mCreateSlotsAdapter: CreateSlotsAdapter

    @Inject
    lateinit var mExcludedWeekDaysAdapter: ExcludedWeekDaysAdapter

    @Inject
    lateinit var mExcludedDatesAdapter: ExcludedDatesAdapter

    private var mStartDate = ""
    private var mEndDate = ""
    private var mViewType = BUNDLE_VIEW_TYPE_CREATE
    private var mAvailabilityData = AvailabilityData()

    private var mDatesList = ArrayList<String>()

    override val toolbar: ToolbarBinding?
        get() = binding.appBarLayout

    override fun init(savedInstanceState: Bundle?) {

        // Set toolbar
        binding.appBarLayout.tvToolbarTitle.text = getString(R.string.st_my_availability)

        // Get arguments
        arguments?.let {
            mStartDate = it.getString(BUNDLE_SELECTED_DATE) ?: ""
            mViewType = it.getInt(BUNDLE_VIEW_TYPE) ?: BUNDLE_VIEW_TYPE_CREATE
            binding.tvDate.text = mStartDate
            mAvailabilityData = it.getParcelable(BUNDLE_AVAILABILITY_DATA) ?: AvailabilityData()

            if (it.getInt(BUNDLE_VIEW_TYPE) == BUNDLE_VIEW_TYPE_EDIT) {
                binding.tvRepeatTillEnd.visibility = View.GONE
                binding.tvRepeatTill.visibility = View.GONE
                binding.tvExclude.visibility = View.GONE
                binding.spnrExclude.visibility = View.GONE
                binding.rvWeeks.visibility = View.GONE
                binding.tvExcludeDatesLabel.visibility = View.GONE
                binding.tvExcludeDates.visibility = View.GONE
                binding.rvDate.visibility = View.GONE
                binding.btnAddDifferentSlot.visibility=View.VISIBLE

                if (mAvailabilityData.slotType == SLOTS_TYPE_CUSTOM) {
                    binding.cbAutoGenerated.isChecked = false
                    binding.cbCustomSlots.isChecked = true
                    mSlotType = SLOTS_TYPE_CUSTOM
                } else {
                    binding.cbAutoGenerated.isChecked = true
                    binding.cbCustomSlots.isChecked = false
                    mSlotType = SLOTS_TYPE_AUTO
                }

                // Update adapter
                mAvailabilityData.availabilitySlots?.let { it1 -> mCreateSlotsAdapter.updateData(it1) }

            } else {
                val mList = listOf(AvailabilityTimeSlots())
                mSlotType = SLOTS_TYPE_AUTO
                mCreateSlotsAdapter.updateData(mList)
            }
        }

        // Set adapter
        binding.rvSlots.adapter = mCreateSlotsAdapter
        binding.rvWeeks.adapter = mExcludedWeekDaysAdapter
        binding.rvDate.adapter = mExcludedDatesAdapter

        // Set click listener
        binding.cbAutoGenerated.setOnClickListener(this)
        binding.cbCustomSlots.setOnClickListener(this)
        binding.tvDate.setOnClickListener(this)
        binding.btnAddDifferentSlot.setOnClickListener(this)
        binding.tvExcludeDates.setOnClickListener(this)
        binding.tvRepeatTill.setOnClickListener(this)
        binding.btnSubmit.setOnClickListener(this)

        initSpinner()



    }

    override val viewModel: BaseViewModel?
        get() = mViewModel

    override fun observeProperties() {
        mViewModel.onDetailSubmitted().observe(this, Observer {
            showMessage(
                null,
                getString(R.string.st_availability_updated_successfully),
                isShowSnackbarMessage = true
            )
            // Send broadcast
            requireContext().sendBroadcast(Intent(INTENT_AVAILABILITY))
            (activity as BaseAppCompactActivity<*>).onBackPressedDispatcher.onBackPressed()
        })
    }

    private fun initSpinner() {
        // Data for the Spinner
        val weekOptions = resources.getStringArray(R.array.week_days)

        // Create an ArrayAdapter using a simple spinner layout and the list of options
        val weekAdapter =
            ArrayAdapter(requireContext(), android.R.layout.simple_spinner_item, weekOptions)

        // Specify the layout to use when the list of choices appears
        weekAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)

        // Set the adapter to the Spinner
        binding.spnrExclude.adapter = weekAdapter

        // Set an item selection listener for the Spinner
        binding.spnrExclude.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(
                parent: AdapterView<*>,
                view: View,
                position: Int,
                id: Long
            ) {
                // Get the selected item
                val selectedOption = parent.getItemAtPosition(position).toString()
                if (position != 0) {
                    mExcludedWeekDaysAdapter.updateData(selectedOption)
                }
            }

            override fun onNothingSelected(parent: AdapterView<*>) {
                // Handle case where no option is selected
            }
        }
    }


    override fun onClick(v: View?) {
        when (v?.id) {
            R.id.btnSubmit -> {
                // Api call
                if (mViewType == BUNDLE_VIEW_TYPE_CREATE) {
                    mViewModel.createAvailability(
                        mStartDate,
                        mEndDate,
                        mCreateSlotsAdapter.getSlots(),
                        mDatesList,
                        mExcludedWeekDaysAdapter.getList(),
                        mSlotType
                    )
                } else {
                    mViewModel.updateAvailabilitySlot(
                        mStartDate,
                        mCreateSlotsAdapter.getSlots(),
                        mSlotType
                    )
                }
            }

            R.id.cbAutoGenerated -> {
                binding.cbAutoGenerated.isChecked = true
                binding.cbCustomSlots.isChecked = false
                binding.btnAddDifferentSlot.visibility=View.GONE
                mSlotType = SLOTS_TYPE_AUTO
                val mList = listOf(AvailabilityTimeSlots("", "", "", mutableListOf()))
                mCreateSlotsAdapter.updateData(mList)
            }

            R.id.cbCustomSlots -> {
                binding.cbCustomSlots.isChecked = true
                binding.cbAutoGenerated.isChecked = false
                binding.btnAddDifferentSlot.visibility=View.GONE
                mSlotType = SLOTS_TYPE_CUSTOM
                val mList = listOf(AvailabilityTimeSlots("", "", "", mutableListOf()))
                mCreateSlotsAdapter.updateData(mList)

            }

            R.id.btnAddDifferentSlot -> {
                mCreateSlotsAdapter.addDurationSlot()
                binding.btnAddDifferentSlot.visibility = View.GONE
            }

            R.id.tvDate -> {
                datePicker { selectedDate ->
                    mStartDate = selectedDate
                    binding.tvDate.text = mStartDate
                }
            }

            R.id.tvRepeatTill -> {
                if (mStartDate.isBlank()) {
                    showMessage(
                        null,
                        getString(R.string.st_please_select_start_time_first),
                        isShowSnackbarMessage = true,
                        true
                    )
                } else {
                    datePicker { selectedDate ->
                        mEndDate = selectedDate
                        binding.tvRepeatTill.text = mEndDate
                    }
                }
            }

            R.id.tvExcludeDates -> {
                datePicker { selectedDate ->
                    if (!mDatesList.contains(selectedDate)) {
                        mDatesList.add(selectedDate)
                        mExcludedDatesAdapter.updateData(mDatesList)
                    }

                }

            }

        }
    }

    override fun onDeleteSlot(listSize: Int, slotPosition: Int) {
        if (listSize == 0) {
            mCreateSlotsAdapter.updateDurationList()
            mCreateSlotsAdapter.deleteSlot(slotPosition)
            if (slotPosition == 0) {
                binding.btnAddDifferentSlot.visibility = View.GONE
            }
        }

    }

    override fun onDeleteDate(position: Int) {
        mDatesList.removeAt(position)
        mExcludedDatesAdapter.updateData(mDatesList)
    }

    override fun onGenerateSlot() {
        hideSoftKeyboard()
        mCreateSlotsAdapter.updateDurationList()
        if (mCreateSlotsAdapter.getSlots().last().slots?.isEmpty() == true) {
            binding.btnAddDifferentSlot.visibility = View.GONE
        } else {
            binding.btnAddDifferentSlot.visibility = View.VISIBLE
        }

    }

    override fun onCancelSlot(position: Int) {
        if (mCreateSlotsAdapter.getSlots().last().slots?.isEmpty() == true) {
            binding.btnAddDifferentSlot.visibility = View.GONE
        } else {
            binding.btnAddDifferentSlot.visibility = View.VISIBLE
        }
    }

    override fun onShowError(value: String) {
        showMessage(null, value, isShowSnackbarMessage = true, true)
    }

    private fun datePicker(onDateSelected: (String) -> Unit) {
        // Get the current date
        val calendar = Calendar.getInstance()
        val year = calendar.get(Calendar.YEAR)
        val month = calendar.get(Calendar.MONTH)
        val day = calendar.get(Calendar.DAY_OF_MONTH)

        // Create the DatePickerDialog
        val datePickerDialog =
            DatePickerDialog(
                requireContext(),
                { _, selectedYear, selectedMonth, selectedDay ->
                    // Update the TextView with the selected date
                    onDateSelected(
                        GeneralFunctions.changeDateFormat(
                            "$selectedYear-${selectedMonth + 1}-$selectedDay",
                            Constants.REQUEST_DATE_FORMAT_SERVER, REQUEST_DATE_FORMAT_SERVER
                        )
                    )


                },
                year,
                month,
                day
            )


        // Show the DatePickerDialog
        // Parse the date and convert it to milliseconds
        val dateFormat = SimpleDateFormat(Constants.REQUEST_DATE_FORMAT_SERVER, Locale.getDefault())
        datePickerDialog.datePicker.minDate = dateFormat.parse(mStartDate)?.time ?: 0L
        datePickerDialog.show()
    }

    override fun onSelect(calendar: MutableList<Calendar>?) {
    }

}
